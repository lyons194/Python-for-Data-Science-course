#Exercises from the first chapter.  A crash course in Python.

#Part 1

#DATA TYPES

#Numbers

1 + 1
1*3
1/2
2**4
4%2
5%2
(2+3) * (5+5)

#Variable Assignment

name_of_var = 2
x = 2
y = 3
z = x + y
z

#Strings

'single quotes'
"double quotes"

#Printing
x = 'hello'
x
print(x)
num = 12
name = 'Sam'
print('My number is: {one}, and my name is {two}'.format(one=num, two=name))
print('My number is: {}, and my name is: {}'.format(num, name))

#Index Notation for strings:
s = 'hello'
s[4]
s[0:]
s[:3]
s[2:4]


#Lists
o = [1, 2, 3]
o = ['a', 'b', 'c']
o.append('d')
o[0]
o[1:3]
o[0] = 'NEW'
o
nest_list = [1, 2, [3, 4]]
nest_list[2][1]

new_nest_list = [1, 2, 3 [4, 5, ['target']]]
new_nest_list[3][2][0]
print(new_nest_list[3][2][0])



#Part 2

#Dictionaries

d = {'key1':'value', 'key2':value}
d['key1']
d['key2']

#Nested dictionary / nested list.

e = {'k1':[1, 2, 3]}
e['k1']
e['k1'][1]

f = {'k1':{'innerkey':[1, 2, 3]}}
f['k1']['innerkey'][1]

#Note: Dictionaries do not store any value in any order.  They simply store key-related pairs for data types.


#Booleans

True
False


#Tuples

t = (1, 2, 3)
t[0]

#Key difference between tuples and lists: tuples are immutable.  Use a tuple when you want to make sure that a user can't change the data inside of a program.


#Sets

{1, 2, 3}

#Note:  A set is a collection of unique elements.

{1, 1, 1, 2, 2, 2, 3, 3, 4}

#Note: You can use the set() function to print all of the unique elements from a batch of data (i.e. a list).

set([1, 1, 1, 2, 2, 2, 2, 4, 4, 5, 6, 7, 7, 7, 7, 7])


#Adding to sets:

s = {1, 2, 3}
s.add(5)

#Try to add 5 again?  No error message will happen, but the set will remain unchanged.



#Comparison Elements.

1 > 2

1 < 2

1 >= 2

1 <= 1

1 == 1

1 == 2

1 != 3

'hi' == 'bye'

'hi' != 'bye'

1 < 2 and 2 < 3

1 < 2 and 2 > 3

(1 < 2) and (2 > 3)

(1 < 2) or (2 > 3) or (1 == 1)



#If, elif, else statements.

if 1 < 2:
	print('yep!')

if True:
	x = 2 + 2

if 1 == 2:
	print('First')
else:
	print('last')


if 1 != 2:
	print('First')
else:
	print('last')


if 1 == 2:
	print('First')
elif 3 == 3:
	print('Middle')
else:
	print('last')


if 1 == 2:
	print('First')
elif 4 == 4:
	print('second')
elif 3 == 3:
	print('Middle')
else:
	print('last')

#Note in the above example that only the first example of a True condition was printed.



#Part 3


#For loops

seq = [1, 2, 3, 4, 5]
for item in seq:
	print(item)

#Note:  The temporary variable name (i.e. 'item' in this example) can have whatever name you want it to have.


for screwdriver in seq:
	print('screwdriver')


for num in seq:
	print('hello')



#While loop

i = 1
while i < 5:
	print('i is: {}'.format(i))
	i = i + 1



#Range

for x in seq:
	print(x)

#Note: range is a generator of numerical values.

range(0,5)

for x in range(0,5):
	print(x)

list(range(0,5))

list(range(10))



#List Comprehension

x = [1, 2, 3, 4]
out = []

for num in x:
	out.append(num**2)

print(out)


#Note: continually appending to lists is quite common in Python; therefore, we have list comprehension.
#Note: the example below will translate the for loop above using list comprehension.


[num**2 for num in x]

out = [num**2 for num in x]


#Note: as we can observe, instead of having to define out, and then create a loop where the append function is being continuously used, we can use list comprehension to condense the task we want completed into one line of code.
#Note: think of this process as a 'for' loop in reverse.




#Functions

def my_func(param1):
	print(param1)

my_func('hello')


def my_func(name):
	print('Hello ' + name)

my_func('Sean')


def my_func(name='Default Name'):
	print('Hello ' + name)

my_func()

my_func('Sean')

my_func


def square(num):
	return num**2

output = square(2)

output


#Note:  Difference between print and return.  When you print something, you're simply printing it for display.  When you're returning something, you're returning the result, but also storing it within the function. 


def square(num):
	"""
	THIS IS A DOCSTRING.
	CAN GO MULTIPLE LINES.
	THIS FUNCTION SQUARES A NUMBER.
	"""
	return num**2





